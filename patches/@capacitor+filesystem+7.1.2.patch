diff --git a/node_modules/@capacitor/filesystem/android/.classpath b/node_modules/@capacitor/filesystem/android/.classpath
new file mode 100644
index 0000000..0a3280e
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/.classpath
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-21/"/>
+	<classpathentry kind="con" path="org.eclipse.buildship.core.gradleclasspathcontainer"/>
+	<classpathentry kind="output" path="bin/default"/>
+</classpath>
diff --git a/node_modules/@capacitor/filesystem/android/.project b/node_modules/@capacitor/filesystem/android/.project
new file mode 100644
index 0000000..27e94b4
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/.project
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>capacitor-filesystem</name>
+	<comment>Project capacitor-filesystem created by Buildship.</comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.buildship.core.gradleprojectbuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>org.eclipse.buildship.core.gradleprojectnature</nature>
+	</natures>
+	<filteredResources>
+		<filter>
+			<id>1752471583731</id>
+			<name></name>
+			<type>30</type>
+			<matcher>
+				<id>org.eclipse.core.resources.regexFilterMatcher</id>
+				<arguments>node_modules|\.git|__CREATED_BY_JAVA_LANGUAGE_SERVER__</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
+</projectDescription>
diff --git a/node_modules/@capacitor/filesystem/android/.settings/org.eclipse.buildship.core.prefs b/node_modules/@capacitor/filesystem/android/.settings/org.eclipse.buildship.core.prefs
new file mode 100644
index 0000000..68c9fab
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/.settings/org.eclipse.buildship.core.prefs
@@ -0,0 +1,2 @@
+connection.project.dir=../../../../android
+eclipse.preferences.version=1
diff --git a/node_modules/@capacitor/filesystem/android/bin/build.gradle b/node_modules/@capacitor/filesystem/android/bin/build.gradle
new file mode 100644
index 0000000..96f596a
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/bin/build.gradle
@@ -0,0 +1,69 @@
+ext {
+    junitVersion = project.hasProperty('junitVersion') ? rootProject.ext.junitVersion : '4.13.2'
+    androidxAppCompatVersion = project.hasProperty('androidxAppCompatVersion') ? rootProject.ext.androidxAppCompatVersion : '1.7.0'
+    androidxJunitVersion = project.hasProperty('androidxJunitVersion') ? rootProject.ext.androidxJunitVersion : '1.2.1'
+    androidxEspressoCoreVersion = project.hasProperty('androidxEspressoCoreVersion') ? rootProject.ext.androidxEspressoCoreVersion : '3.6.1'
+}
+
+buildscript {
+    ext.kotlin_version = project.hasProperty("kotlin_version") ? rootProject.ext.kotlin_version : '1.9.24'
+    repositories {
+        google()
+        mavenCentral()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:8.7.1'
+        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
+    }
+}
+
+apply plugin: 'com.android.library'
+apply plugin: 'kotlin-android'
+
+android {
+    namespace "com.capacitorjs.plugins.filesystem"
+    compileSdk project.hasProperty('compileSdkVersion') ? rootProject.ext.compileSdkVersion : 35
+    defaultConfig {
+        minSdkVersion project.hasProperty('minSdkVersion') ? rootProject.ext.minSdkVersion : 23
+        targetSdkVersion project.hasProperty('targetSdkVersion') ? rootProject.ext.targetSdkVersion : 35
+        versionCode 1
+        versionName "1.0"
+        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+    lintOptions {
+        abortOnError false
+    }
+    compileOptions {
+        sourceCompatibility JavaVersion.VERSION_21
+        targetCompatibility JavaVersion.VERSION_21
+    }
+}
+
+kotlin {
+    jvmToolchain(21)
+}
+
+repositories {
+    google()
+    mavenCentral()
+}
+
+
+dependencies {
+    implementation fileTree(dir: 'libs', include: ['*.jar'])
+    implementation "io.ionic.libs:ionfilesystem-android:1.0.0"
+    implementation project(':capacitor-android')
+    implementation "androidx.appcompat:appcompat:$androidxAppCompatVersion"
+
+    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.4")
+
+    testImplementation "junit:junit:$junitVersion"
+    androidTestImplementation "androidx.test.ext:junit:$androidxJunitVersion"
+    androidTestImplementation "androidx.test.espresso:espresso-core:$androidxEspressoCoreVersion"
+}
diff --git a/node_modules/@capacitor/filesystem/android/bin/src/main/AndroidManifest.xml b/node_modules/@capacitor/filesystem/android/bin/src/main/AndroidManifest.xml
new file mode 100644
index 0000000..a2f47b6
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/bin/src/main/AndroidManifest.xml
@@ -0,0 +1,2 @@
+<manifest xmlns:android="http://schemas.android.com/apk/res/android">
+</manifest>
diff --git a/node_modules/@capacitor/filesystem/android/bin/src/main/kotlin/com/capacitorjs/plugins/filesystem/FilesystemErrors.kt b/node_modules/@capacitor/filesystem/android/bin/src/main/kotlin/com/capacitorjs/plugins/filesystem/FilesystemErrors.kt
new file mode 100644
index 0000000..056edae
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/bin/src/main/kotlin/com/capacitorjs/plugins/filesystem/FilesystemErrors.kt
@@ -0,0 +1,101 @@
+package com.capacitorjs.plugins.filesystem
+
+import io.ionic.libs.ionfilesystemlib.model.IONFILEExceptions
+
+object FilesystemErrors {
+    private fun formatErrorCode(number: Int): String {
+        return "OS-PLUG-FILE-" + number.toString().padStart(4, '0')
+    }
+
+    data class ErrorInfo(
+        val code: String,
+        val message: String
+    )
+
+    fun invalidInputMethod(methodName: String): ErrorInfo = ErrorInfo(
+        code = formatErrorCode(5),
+        message = "The '$methodName' input parameters aren't valid."
+    )
+
+    fun invalidPath(path: String): ErrorInfo = ErrorInfo(
+        code = formatErrorCode(6),
+        message = "Invalid ${if (path.isNotBlank()) "'$path' " else ""}path."
+    )
+
+    val filePermissionsDenied: ErrorInfo = ErrorInfo(
+        code = formatErrorCode(7),
+        message = "Unable to do file operation, user denied permission request."
+    )
+
+    fun doesNotExist(methodName: String, path: String): ErrorInfo = ErrorInfo(
+        code = formatErrorCode(8),
+        message = "'$methodName' failed because file ${if (path.isNotBlank()) "at '$path' " else ""}does not exist."
+    )
+
+    fun notAllowed(methodName: String, notAllowedFor: String): ErrorInfo = ErrorInfo(
+        code = formatErrorCode(9),
+        message = "'$methodName' not supported for $notAllowedFor."
+    )
+
+    fun directoryCreationAlreadyExists(path: String): ErrorInfo = ErrorInfo(
+        code = formatErrorCode(10),
+        message = "Directory ${if (path.isNotBlank()) "at '$path' " else ""}already exists, cannot be overwritten."
+    )
+
+    val missingParentDirectories: ErrorInfo = ErrorInfo(
+        code = formatErrorCode(11),
+        message = "Missing parent directory â€“ possibly recursive=false was passed or parent directory creation failed."
+    )
+
+    val cannotDeleteChildren: ErrorInfo = ErrorInfo(
+        code = formatErrorCode(12),
+        message = "Cannot delete directory with children; received recursive=false but directory has contents."
+    )
+
+    fun operationFailed(methodName: String, errorMessage: String): ErrorInfo = ErrorInfo(
+        code = formatErrorCode(13),
+        message = "'$methodName' failed with${if (errorMessage.isNotBlank()) ": $errorMessage" else "an unknown error."}"
+    )
+}
+
+fun Throwable.toFilesystemError(methodName: String): FilesystemErrors.ErrorInfo = when (this) {
+
+    is IONFILEExceptions.UnresolvableUri -> FilesystemErrors.invalidPath(this.uri)
+
+    is IONFILEExceptions.DoesNotExist -> FilesystemErrors.doesNotExist(methodName, this.path)
+
+    is IONFILEExceptions.NotSupportedForContentScheme -> FilesystemErrors.notAllowed(
+        methodName,
+        notAllowedFor = "content:// URIs"
+    )
+
+    is IONFILEExceptions.NotSupportedForDirectory -> FilesystemErrors.notAllowed(
+        methodName,
+        notAllowedFor = "directories"
+    )
+
+    is IONFILEExceptions.NotSupportedForFiles -> FilesystemErrors.notAllowed(
+        methodName,
+        notAllowedFor = "files, only directories are supported"
+    )
+
+    is IONFILEExceptions.CreateFailed.AlreadyExists ->
+        FilesystemErrors.directoryCreationAlreadyExists(this.path)
+
+    is IONFILEExceptions.CreateFailed.NoParentDirectory -> FilesystemErrors.missingParentDirectories
+
+    is IONFILEExceptions.DeleteFailed.CannotDeleteChildren -> FilesystemErrors.cannotDeleteChildren
+
+    is IONFILEExceptions.CopyRenameFailed.MixingFilesAndDirectories,
+    is IONFILEExceptions.CopyRenameFailed.LocalToContent,
+    is IONFILEExceptions.CopyRenameFailed.SourceAndDestinationContent ->
+        FilesystemErrors.notAllowed(methodName, "the provided source and destinations")
+
+    is IONFILEExceptions.CopyRenameFailed.DestinationDirectoryExists ->
+        FilesystemErrors.directoryCreationAlreadyExists(this.path)
+
+    is IONFILEExceptions.CopyRenameFailed.NoParentDirectory ->
+        FilesystemErrors.missingParentDirectories
+
+    else -> FilesystemErrors.operationFailed(methodName, this.localizedMessage ?: "")
+}
\ No newline at end of file
diff --git a/node_modules/@capacitor/filesystem/android/bin/src/main/kotlin/com/capacitorjs/plugins/filesystem/FilesystemMethodOptions.kt b/node_modules/@capacitor/filesystem/android/bin/src/main/kotlin/com/capacitorjs/plugins/filesystem/FilesystemMethodOptions.kt
new file mode 100644
index 0000000..6222c03
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/bin/src/main/kotlin/com/capacitorjs/plugins/filesystem/FilesystemMethodOptions.kt
@@ -0,0 +1,129 @@
+package com.capacitorjs.plugins.filesystem
+
+import com.getcapacitor.PluginCall
+import io.ionic.libs.ionfilesystemlib.model.IONFILEEncoding
+import io.ionic.libs.ionfilesystemlib.model.IONFILEFolderType
+import io.ionic.libs.ionfilesystemlib.model.IONFILEReadInChunksOptions
+import io.ionic.libs.ionfilesystemlib.model.IONFILEReadOptions
+import io.ionic.libs.ionfilesystemlib.model.IONFILESaveMode
+import io.ionic.libs.ionfilesystemlib.model.IONFILESaveOptions
+import io.ionic.libs.ionfilesystemlib.model.IONFILEUri
+
+internal const val INPUT_APPEND = "append"
+private const val INPUT_PATH = "path"
+private const val INPUT_DIRECTORY = "directory"
+private const val INPUT_ENCODING = "encoding"
+private const val INPUT_CHUNK_SIZE = "chunkSize"
+private const val INPUT_DATA = "data"
+private const val INPUT_RECURSIVE = "recursive"
+private const val INPUT_FROM = "from"
+private const val INPUT_FROM_DIRECTORY = "directory"
+private const val INPUT_TO = "to"
+private const val INPUT_TO_DIRECTORY = "toDirectory"
+
+internal data class ReadFileOptions(
+    val uri: IONFILEUri.Unresolved,
+    val options: IONFILEReadOptions
+)
+
+internal data class ReadFileInChunksOptions(
+    val uri: IONFILEUri.Unresolved,
+    val options: IONFILEReadInChunksOptions
+)
+
+internal data class WriteFileOptions(
+    val uri: IONFILEUri.Unresolved,
+    val options: IONFILESaveOptions
+)
+
+internal data class SingleUriWithRecursiveOptions(
+    val uri: IONFILEUri.Unresolved,
+    val recursive: Boolean
+)
+
+internal data class DoubleUri(
+    val fromUri: IONFILEUri.Unresolved,
+    val toUri: IONFILEUri.Unresolved,
+)
+
+/**
+ * @return [ReadFileOptions] from JSON inside [PluginCall], or null if input is invalid
+ */
+internal fun PluginCall.getReadFileOptions(): ReadFileOptions? {
+    val uri = getSingleIONFILEUri() ?: return null
+    val encoding = IONFILEEncoding.fromEncodingName(getString(INPUT_ENCODING))
+    return ReadFileOptions(uri = uri, options = IONFILEReadOptions(encoding))
+}
+
+/**
+ * @return [ReadFileInChunksOptions] from JSON inside [PluginCall], or null if input is invalid
+ */
+internal fun PluginCall.getReadFileInChunksOptions(): ReadFileInChunksOptions? {
+    val uri = getSingleIONFILEUri() ?: return null
+    val encoding = IONFILEEncoding.fromEncodingName(getString(INPUT_ENCODING))
+    val chunkSize = getInt(INPUT_CHUNK_SIZE)?.takeIf { it > 0 } ?: return null
+    return ReadFileInChunksOptions(
+        uri = uri,
+        options = IONFILEReadInChunksOptions(encoding, chunkSize)
+    )
+}
+
+/**
+ * @return [ReadFileOptions] from JSON inside [PluginCall], or null if input is invalid
+ */
+internal fun PluginCall.getWriteFileOptions(): WriteFileOptions? {
+    val uri = getSingleIONFILEUri() ?: return null
+    val data = getString(INPUT_DATA) ?: return null
+    val recursive = getBoolean(INPUT_RECURSIVE) ?: false
+    val append = getBoolean(INPUT_APPEND) ?: false
+    val saveMode = if (append) IONFILESaveMode.APPEND else IONFILESaveMode.WRITE
+    val encoding = IONFILEEncoding.fromEncodingName(getString(INPUT_ENCODING))
+    return WriteFileOptions(
+        uri = uri,
+        options = IONFILESaveOptions(
+            data = data,
+            encoding = encoding,
+            mode = saveMode,
+            createFileRecursive = recursive
+        )
+    )
+}
+
+/**
+ * @return [SingleUriWithRecursiveOptions] from JSON inside [PluginCall], or null if input is invalid
+ */
+internal fun PluginCall.getSingleUriWithRecursiveOptions(): SingleUriWithRecursiveOptions? {
+    val uri = getSingleIONFILEUri() ?: return null
+    val recursive = getBoolean(INPUT_RECURSIVE) ?: false
+    return SingleUriWithRecursiveOptions(uri = uri, recursive = recursive)
+}
+
+/**
+ * @return two uris in form of [DoubleUri] from JSON inside [PluginCall], or null if input is invalid
+ */
+internal fun PluginCall.getDoubleIONFILEUri(): DoubleUri? {
+    val fromPath = getString(INPUT_FROM) ?: return null
+    val fromFolder = IONFILEFolderType.fromStringAlias(getString(INPUT_FROM_DIRECTORY))
+    val toPath = getString(INPUT_TO) ?: return null
+    val toFolder = getString(INPUT_TO_DIRECTORY)?.let { toDirectory ->
+        IONFILEFolderType.fromStringAlias(toDirectory)
+    } ?: fromFolder
+    return DoubleUri(
+        fromUri = IONFILEUri.Unresolved(fromFolder, fromPath),
+        toUri = IONFILEUri.Unresolved(toFolder, toPath),
+    )
+}
+
+/**
+ * return a single [IONFILEUri.Unresolved] from JSON inside [PluginCall], or null if input is invalid
+ */
+internal fun PluginCall.getSingleIONFILEUri(): IONFILEUri.Unresolved? {
+    val path = getString(INPUT_PATH) ?: return null
+    val directoryAlias = getString(INPUT_DIRECTORY)
+    return unresolvedUri(path, directoryAlias)
+}
+
+private fun unresolvedUri(path: String, directoryAlias: String?) = IONFILEUri.Unresolved(
+    parentFolder = IONFILEFolderType.fromStringAlias(directoryAlias),
+    uriPath = path
+)
diff --git a/node_modules/@capacitor/filesystem/android/bin/src/main/kotlin/com/capacitorjs/plugins/filesystem/FilesystemMethodResults.kt b/node_modules/@capacitor/filesystem/android/bin/src/main/kotlin/com/capacitorjs/plugins/filesystem/FilesystemMethodResults.kt
new file mode 100644
index 0000000..b2c0c6a
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/bin/src/main/kotlin/com/capacitorjs/plugins/filesystem/FilesystemMethodResults.kt
@@ -0,0 +1,65 @@
+package com.capacitorjs.plugins.filesystem
+
+import android.net.Uri
+import com.getcapacitor.JSArray
+import com.getcapacitor.JSObject
+import io.ionic.libs.ionfilesystemlib.model.IONFILEFileType
+import io.ionic.libs.ionfilesystemlib.model.IONFILEMetadataResult
+import io.ionic.libs.ionfilesystemlib.model.IONFILESaveMode
+import io.ionic.libs.ionfilesystemlib.model.IONFILEUri
+
+private val OUTPUT_DATA = "data"
+private val OUTPUT_NAME = "name"
+private val OUTPUT_TYPE = "type"
+private val OUTPUT_SIZE = "size"
+private val OUTPUT_MODIFIED_TIME = "mtime"
+private val OUTPUT_CREATED_TIME = "ctime"
+private val OUTPUT_URI = "uri"
+private val OUTPUT_FILES = "files"
+
+/**
+ * @return a result [JSObject] for reading a file
+ */
+fun createReadResultObject(readData: String): JSObject =
+    JSObject().also { it.putOpt(OUTPUT_DATA, readData) }
+
+
+/**
+ * @return a result [JSObject] for writing/append a file
+ */
+fun createWriteResultObject(uri: Uri, mode: IONFILESaveMode): JSObject? =
+    if (mode == IONFILESaveMode.APPEND) {
+        null
+    } else {
+        createUriResultObject(uri)
+    }
+
+/**
+ * @return a result [JSObject] for the list of a directories contents
+ */
+fun createReadDirResultObject(list: List<IONFILEMetadataResult>): JSObject = JSObject().also {
+    it.put(OUTPUT_FILES, JSArray(list.map { child -> child.toResultObject() }))
+}
+
+/**
+ * @return a result [JSObject] for stat, from the [IONFILEMetadataResult] object
+ */
+fun IONFILEMetadataResult.toResultObject(): JSObject = JSObject().apply {
+    put(OUTPUT_NAME, name)
+    put(OUTPUT_TYPE, if (type is IONFILEFileType.Directory) "directory" else "file")
+    put(OUTPUT_SIZE, size)
+    put(OUTPUT_MODIFIED_TIME, lastModifiedTimestamp)
+    put(OUTPUT_CREATED_TIME, createdTimestamp)
+    put(OUTPUT_URI, uri)
+}
+
+/**
+ * @return a result [JSObject] based on a resolved uri [IONFILEUri.Resolved]
+ */
+fun IONFILEUri.Resolved.toResultObject(): JSObject = createUriResultObject(this.uri)
+
+/**
+ * @return a result [JSObject] for an Android [Uri]
+ */
+fun createUriResultObject(uri: Uri): JSObject =
+    JSObject().also { it.put(OUTPUT_URI, uri.toString()) }
\ No newline at end of file
diff --git a/node_modules/@capacitor/filesystem/android/bin/src/main/kotlin/com/capacitorjs/plugins/filesystem/FilesystemPlugin.kt b/node_modules/@capacitor/filesystem/android/bin/src/main/kotlin/com/capacitorjs/plugins/filesystem/FilesystemPlugin.kt
new file mode 100644
index 0000000..fed6e14
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/bin/src/main/kotlin/com/capacitorjs/plugins/filesystem/FilesystemPlugin.kt
@@ -0,0 +1,412 @@
+package com.capacitorjs.plugins.filesystem
+
+import android.Manifest
+import android.media.MediaScannerConnection
+import android.os.Build
+import android.os.Environment
+import android.util.Log
+import com.getcapacitor.JSObject
+import com.getcapacitor.Logger
+import com.getcapacitor.PermissionState
+import com.getcapacitor.Plugin
+import com.getcapacitor.PluginCall
+import com.getcapacitor.PluginMethod
+import com.getcapacitor.annotation.CapacitorPlugin
+import com.getcapacitor.annotation.Permission
+import com.getcapacitor.annotation.PermissionCallback
+import com.getcapacitor.plugin.util.HttpRequestHandler.ProgressEmitter
+import io.ionic.libs.ionfilesystemlib.IONFILEController
+import io.ionic.libs.ionfilesystemlib.model.IONFILECreateOptions
+import io.ionic.libs.ionfilesystemlib.model.IONFILEDeleteOptions
+import io.ionic.libs.ionfilesystemlib.model.IONFILEUri
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.cancel
+import kotlinx.coroutines.flow.catch
+import kotlinx.coroutines.flow.launchIn
+import kotlinx.coroutines.flow.onCompletion
+import kotlinx.coroutines.flow.onEach
+import kotlinx.coroutines.launch
+import org.json.JSONException
+
+private const val PUBLIC_STORAGE = "publicStorage"
+private const val PUBLIC_STORAGE_ABOVE_ANDROID_10 = "publicStorageAboveAPI29"
+private const val PERMISSION_GRANTED = "granted"
+
+@CapacitorPlugin(
+    name = "Filesystem",
+    permissions = [
+        Permission(
+            strings = [Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE],
+            alias = PUBLIC_STORAGE
+        ),
+        /*
+        For SDK versions 30-32 (Android 11 and Android 12)
+        Could be that certain files may require read permission, such as local file path to photos/videos in gallery
+        */
+        Permission(
+            strings = [Manifest.permission.READ_EXTERNAL_STORAGE],
+            alias = PUBLIC_STORAGE_ABOVE_ANDROID_10
+        )
+    ]
+)
+class FilesystemPlugin : Plugin() {
+
+    private var legacyImplementation: LegacyFilesystemImplementation? = null
+
+    private val coroutineScope: CoroutineScope by lazy { CoroutineScope(Dispatchers.Main) }
+    private val controller: IONFILEController by lazy { IONFILEController(context.applicationContext) }
+
+    override fun load() {
+        super.load()
+        legacyImplementation = LegacyFilesystemImplementation(context)
+    }
+
+    override fun handleOnDestroy() {
+        super.handleOnDestroy()
+        coroutineScope.cancel()
+    }
+
+    @PluginMethod
+    fun readFile(call: PluginCall) {
+        val input: ReadFileOptions = call.getReadFileOptions() ?: run {
+            call.sendError(FilesystemErrors.invalidInputMethod(call.methodName))
+            return
+        }
+        runWithPermission(input.uri, call) { uri ->
+            controller.readFile(uri, input.options)
+                .onSuccess { call.sendSuccess(result = createReadResultObject(it)) }
+                .onFailure { call.sendError(it.toFilesystemError(call.methodName)) }
+        }
+    }
+
+    @PluginMethod(returnType = PluginMethod.RETURN_CALLBACK)
+    fun readFileInChunks(call: PluginCall) {
+        val input: ReadFileInChunksOptions = call.getReadFileInChunksOptions() ?: run {
+            call.sendError(FilesystemErrors.invalidInputMethod(call.methodName))
+            return
+        }
+        runWithPermission(input.uri, call) { uri ->
+            controller.readFileInChunks(uri, input.options)
+                .onEach { chunk ->
+                    call.sendSuccess(result = createReadResultObject(chunk), keepCallback = true)
+                }
+                .onCompletion { error ->
+                    if (error == null) {
+                        call.sendSuccess(result = createReadResultObject(""))
+                    }
+                }
+                .catch {
+                    call.sendError(it.toFilesystemError(call.methodName))
+                }
+                .launchIn(coroutineScope)
+        }
+    }
+
+    @PluginMethod
+    fun writeFile(call: PluginCall) {
+        val input: WriteFileOptions = call.getWriteFileOptions() ?: run {
+            call.sendError(FilesystemErrors.invalidInputMethod(call.methodName))
+            return
+        }
+        runWithPermission(input.uri, call) { uri ->
+            controller.saveFile(uri, input.options)
+                .onSuccess { uriSaved ->
+                    // update mediaStore index only if file was written to external storage
+                    if (uri.inExternalStorage) {
+                        uriSaved.path?.let {
+                            MediaScannerConnection.scanFile(context, arrayOf(it), null, null)
+                        }
+                    }
+                    call.sendSuccess(result = createWriteResultObject(uriSaved, input.options.mode))
+                }
+                .onFailure { call.sendError(it.toFilesystemError(call.methodName)) }
+        }
+    }
+
+    @PluginMethod
+    fun appendFile(call: PluginCall) {
+        try {
+            call.data.putOpt(INPUT_APPEND, true)
+        } catch (ex: JSONException) {
+            Log.e(logTag, "Tried to set `append` in `PluginCall`, but got exception", ex)
+            call.sendError(
+                FilesystemErrors.operationFailed(call.methodName, ex.localizedMessage ?: "")
+            )
+            return
+        }
+        writeFile(call)
+    }
+
+    @PluginMethod
+    fun deleteFile(call: PluginCall) {
+        val input = call.getSingleIONFILEUri() ?: run {
+            call.sendError(FilesystemErrors.invalidInputMethod(call.methodName))
+            return
+        }
+        runWithPermission(input, call) { uri ->
+            controller.delete(uri, IONFILEDeleteOptions(recursive = false))
+                .onSuccess { call.sendSuccess() }
+                .onFailure { call.sendError(it.toFilesystemError(call.methodName)) }
+        }
+    }
+
+    @PluginMethod
+    fun mkdir(call: PluginCall) {
+        val input = call.getSingleUriWithRecursiveOptions() ?: run {
+            call.sendError(FilesystemErrors.invalidInputMethod(call.methodName))
+            return
+        }
+        runWithPermission(input.uri, call) { uri ->
+            controller.createDirectory(uri, IONFILECreateOptions(input.recursive))
+                .onSuccess { call.sendSuccess() }
+                .onFailure { call.sendError(it.toFilesystemError(call.methodName)) }
+        }
+    }
+
+    @PluginMethod
+    fun rmdir(call: PluginCall) {
+        val input = call.getSingleUriWithRecursiveOptions() ?: run {
+            call.sendError(FilesystemErrors.invalidInputMethod(call.methodName))
+            return
+        }
+        runWithPermission(input.uri, call) { uri ->
+            controller.delete(uri, IONFILEDeleteOptions(input.recursive))
+                .onSuccess { call.sendSuccess() }
+                .onFailure { call.sendError(it.toFilesystemError(call.methodName)) }
+        }
+    }
+
+    @PluginMethod
+    fun readdir(call: PluginCall) {
+        val input = call.getSingleIONFILEUri() ?: run {
+            call.sendError(FilesystemErrors.invalidInputMethod(call.methodName))
+            return
+        }
+        runWithPermission(input, call) { uri ->
+            controller.listDirectory(uri)
+                .onSuccess { call.sendSuccess(result = createReadDirResultObject(it)) }
+                .onFailure { call.sendError(it.toFilesystemError(call.methodName)) }
+        }
+    }
+
+    @PluginMethod
+    fun getUri(call: PluginCall) {
+        val input = call.getSingleIONFILEUri() ?: run {
+            call.sendError(FilesystemErrors.invalidInputMethod(call.methodName))
+            return
+        }
+        coroutineScope.launch {
+            controller.getFileUri(input)
+                .onSuccess { resolvedUri -> call.sendSuccess(result = resolvedUri.toResultObject()) }
+                .onFailure { call.sendError(it.toFilesystemError(call.methodName)) }
+        }
+    }
+
+    @PluginMethod
+    fun stat(call: PluginCall) {
+        val input = call.getSingleIONFILEUri() ?: run {
+            call.sendError(FilesystemErrors.invalidInputMethod(call.methodName))
+            return
+        }
+        runWithPermission(input, call) { uri ->
+            controller.getMetadata(uri)
+                .onSuccess { metadata -> call.sendSuccess(result = metadata.toResultObject()) }
+                .onFailure { call.sendError(it.toFilesystemError(call.methodName)) }
+        }
+    }
+
+    @PluginMethod
+    fun rename(call: PluginCall) {
+        val input = call.getDoubleIONFILEUri() ?: run {
+            call.sendError(FilesystemErrors.invalidInputMethod(call.methodName))
+            return
+        }
+        runWithPermission(input.fromUri, input.toUri, call) { source, destination ->
+            controller.move(source, destination)
+                .onSuccess { call.sendSuccess() }
+                .onFailure { call.sendError(it.toFilesystemError(call.methodName)) }
+        }
+    }
+
+    @PluginMethod
+    fun copy(call: PluginCall) {
+        val input = call.getDoubleIONFILEUri() ?: run {
+            call.sendError(FilesystemErrors.invalidInputMethod(call.methodName))
+            return
+        }
+        runWithPermission(input.fromUri, input.toUri, call) { source, destination ->
+            controller.copy(source, destination)
+                .onSuccess { call.sendSuccess(createUriResultObject(it)) }
+                .onFailure { call.sendError(it.toFilesystemError(call.methodName)) }
+        }
+    }
+
+    @PluginMethod
+    @Deprecated("Use @capacitor/file-transfer plugin instead")
+    fun downloadFile(call: PluginCall) {
+        try {
+            val directory = call.getString("directory", Environment.DIRECTORY_DOWNLOADS)
+
+            if (legacyImplementation?.isPublicDirectory(directory) == true &&
+                !isStoragePermissionGranted(false)
+            ) {
+                requestAllPermissions(call, "permissionCallback")
+                return
+            }
+
+            val emitter = ProgressEmitter { bytes: Int?, contentLength: Int? ->
+                val ret = JSObject()
+                ret.put("url", call.getString("url"))
+                ret.put("bytes", bytes)
+                ret.put("contentLength", contentLength)
+                notifyListeners("progress", ret)
+            }
+
+            legacyImplementation?.downloadFile(
+                call,
+                bridge,
+                emitter,
+                object : LegacyFilesystemImplementation.FilesystemDownloadCallback {
+                    override fun onSuccess(result: JSObject) {
+                        // update mediaStore index only if file was written to external storage
+                        if (legacyImplementation?.isPublicDirectory(directory) == true) {
+                            MediaScannerConnection.scanFile(
+                                context,
+                                arrayOf(result.getString("path")),
+                                null,
+                                null
+                            )
+                        }
+                        call.resolve(result)
+                    }
+
+                    override fun onError(error: Exception) {
+                        call.reject("Error downloading file: " + error.localizedMessage, error)
+                    }
+                }
+            )
+        } catch (ex: Exception) {
+            call.reject("Error downloading file: " + ex.localizedMessage, ex)
+        }
+    }
+
+    @PluginMethod
+    override fun checkPermissions(call: PluginCall) {
+        if (isStoragePermissionGranted(false)) {
+            call.sendSuccess(JSObject().also { it.put(PUBLIC_STORAGE, PERMISSION_GRANTED) })
+        } else {
+            super.checkPermissions(call)
+        }
+    }
+
+    @PluginMethod
+    override fun requestPermissions(call: PluginCall) {
+        if (isStoragePermissionGranted(false)) {
+            call.sendSuccess(JSObject().also { it.put(PUBLIC_STORAGE, PERMISSION_GRANTED) })
+        } else {
+            super.requestPermissions(call)
+        }
+    }
+
+    @PermissionCallback
+    private fun permissionCallback(call: PluginCall) {
+        if (!isStoragePermissionGranted(true)) {
+            Logger.debug(logTag, "User denied storage permission")
+            call.sendError(FilesystemErrors.filePermissionsDenied)
+            return
+        }
+
+        when (call.methodName) {
+            // appendFile and writeFile have the same implementation, hence the same method is called;
+            //  the only difference being that we add a boolean for append in the PluginCall,
+            //  which is done before this method is called.
+            "appendFile", "writeFile" -> writeFile(call)
+            "deleteFile" -> deleteFile(call)
+            "mkdir" -> mkdir(call)
+            "rmdir" -> rmdir(call)
+            "rename" -> rename(call)
+            "copy" -> copy(call)
+            "readFile" -> readFile(call)
+            "readFileInChunks" -> readFileInChunks(call)
+            "readdir" -> readdir(call)
+            "getUri" -> getUri(call)
+            "stat" -> stat(call)
+            "downloadFile" -> downloadFile(call)
+        }
+    }
+
+    /**
+     * Runs a suspend code if the app has permission to access the uri
+     *
+     * Will ask for permission if it has not been granted.
+     *
+     * May return an error if the uri is not resolvable.
+     *
+     * @param uri the uri pointing to the file / directory
+     * @param call the capacitor plugin call
+     * @param onPermissionGranted the callback to run the suspending code
+     */
+    private fun runWithPermission(
+        uri: IONFILEUri.Unresolved,
+        call: PluginCall,
+        onPermissionGranted: suspend (resolvedUri: IONFILEUri.Resolved) -> Unit
+    ) {
+        coroutineScope.launch {
+            controller.getFileUri(uri)
+                .onSuccess { resolvedUri ->
+                    // certain files like a photo/video in gallery may require read permission on Android 11 and 12.
+                    if (
+                        resolvedUri.inExternalStorage
+                        && !isStoragePermissionGranted(shouldRequestAboveAndroid10 = uri.parentFolder == null)
+                    ) {
+                        requestAllPermissions(call, this@FilesystemPlugin::permissionCallback.name)
+                    } else {
+                        onPermissionGranted(resolvedUri)
+                    }
+                }
+                .onFailure { call.sendError(it.toFilesystemError(call.methodName)) }
+        }
+    }
+
+    /**
+     * Runs a suspend code if the app has permission to access both to and from uris
+     *
+     * Will ask for permission if it has not been granted.
+     *
+     * May return an error if the uri is not resolvable.
+     *
+     * @param fromUri the source uri pointing to the file / directory
+     * @param toUri the destination uri pointing to the file / directory
+     * @param call the capacitor plugin call
+     * @param onPermissionGranted the callback to run the suspending code
+     */
+    private fun runWithPermission(
+        fromUri: IONFILEUri.Unresolved,
+        toUri: IONFILEUri.Unresolved,
+        call: PluginCall,
+        onPermissionGranted: suspend (resolvedSourceUri: IONFILEUri.Resolved, resolvedDestinationUri: IONFILEUri.Resolved) -> Unit
+    ) {
+        runWithPermission(fromUri, call) { resolvedSourceUri ->
+            runWithPermission(toUri, call) { resolvedDestinationUri ->
+                onPermissionGranted(resolvedSourceUri, resolvedDestinationUri)
+            }
+        }
+    }
+
+    /**
+     * Checks the the given permission is granted or not
+     * @param shouldRequestAboveAndroid10 whether or not should check for read permission above android 10
+     *  May vary with the kind of file path that is provided.
+     * @return Returns true if the app is running on Android 13 (API 33) or newer, or if the permission is already granted
+     * or false if it is denied.
+     */
+    private fun isStoragePermissionGranted(shouldRequestAboveAndroid10: Boolean): Boolean = when {
+        Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU -> true
+
+        Build.VERSION.SDK_INT >= Build.VERSION_CODES.R ->
+            !shouldRequestAboveAndroid10 || getPermissionState(PUBLIC_STORAGE_ABOVE_ANDROID_10) == PermissionState.GRANTED
+
+        else -> getPermissionState(PUBLIC_STORAGE) == PermissionState.GRANTED
+    }
+}
\ No newline at end of file
diff --git a/node_modules/@capacitor/filesystem/android/bin/src/main/kotlin/com/capacitorjs/plugins/filesystem/LegacyFilesystemImplementation.kt b/node_modules/@capacitor/filesystem/android/bin/src/main/kotlin/com/capacitorjs/plugins/filesystem/LegacyFilesystemImplementation.kt
new file mode 100644
index 0000000..cfe09ec
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/bin/src/main/kotlin/com/capacitorjs/plugins/filesystem/LegacyFilesystemImplementation.kt
@@ -0,0 +1,169 @@
+package com.capacitorjs.plugins.filesystem
+
+import android.content.Context
+import android.net.Uri
+import android.os.Environment
+import android.os.Handler
+import android.os.Looper
+import com.getcapacitor.Bridge
+import com.getcapacitor.JSObject
+import com.getcapacitor.PluginCall
+import com.getcapacitor.plugin.util.HttpRequestHandler.HttpURLConnectionBuilder
+import com.getcapacitor.plugin.util.HttpRequestHandler.ProgressEmitter
+import org.json.JSONException
+import java.io.File
+import java.io.FileOutputStream
+import java.io.IOException
+import java.net.URISyntaxException
+import java.net.URL
+import kotlin.concurrent.thread
+
+class LegacyFilesystemImplementation internal constructor(private val context: Context) {
+    fun downloadFile(
+        call: PluginCall,
+        bridge: Bridge,
+        emitter: ProgressEmitter?,
+        callback: FilesystemDownloadCallback
+    ) {
+        val urlString = call.getString("url", "")
+        val handler = Handler(Looper.getMainLooper())
+
+        thread {
+            try {
+                val result =
+                    doDownloadInBackground(urlString, call, bridge, emitter)
+                handler.post { callback.onSuccess(result) }
+            } catch (error: Exception) {
+                handler.post { callback.onError(error) }
+            }
+        }
+    }
+
+    /**
+     * True if the given directory string is a public storage directory, which is accessible by the user or other apps.
+     * @param directory the directory string.
+     */
+    fun isPublicDirectory(directory: String?): Boolean {
+        return "DOCUMENTS" == directory || "EXTERNAL_STORAGE" == directory
+    }
+
+    private fun getDirectory(directory: String): File? {
+        val c = this.context
+        when (directory) {
+            "DOCUMENTS" -> return Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOCUMENTS)
+            "DATA", "LIBRARY" -> return c.filesDir
+            "CACHE" -> return c.cacheDir
+            "EXTERNAL" -> return c.getExternalFilesDir(null)
+            "EXTERNAL_STORAGE" -> return Environment.getExternalStorageDirectory()
+        }
+        return null
+    }
+
+    private fun getFileObject(path: String, directory: String?): File? {
+        if (directory == null) {
+            val u = Uri.parse(path)
+            if (u.scheme == null || u.scheme == "file") {
+                return File(u.path)
+            }
+        }
+
+        val androidDirectory = this.getDirectory(directory!!)
+
+        if (androidDirectory == null) {
+            return null
+        } else {
+            if (!androidDirectory.exists()) {
+                androidDirectory.mkdir()
+            }
+        }
+
+        return File(androidDirectory, path)
+    }
+
+    @Throws(IOException::class, URISyntaxException::class, JSONException::class)
+    private fun doDownloadInBackground(
+        urlString: String?,
+        call: PluginCall,
+        bridge: Bridge,
+        emitter: ProgressEmitter?
+    ): JSObject {
+        val headers = call.getObject("headers", JSObject())
+        val params = call.getObject("params", JSObject())
+        val connectTimeout = call.getInt("connectTimeout")
+        val readTimeout = call.getInt("readTimeout")
+        val disableRedirects = call.getBoolean("disableRedirects") ?: false
+        val shouldEncode = call.getBoolean("shouldEncodeUrlParams") ?: true
+        val progress = call.getBoolean("progress") ?: false
+
+        val method = call.getString("method")?.uppercase() ?: "GET"
+        val path = call.getString("path")!!
+        val directory = call.getString("directory", Environment.DIRECTORY_DOWNLOADS)
+
+        val url = URL(urlString)
+        val file = getFileObject(path, directory)
+
+        val connectionBuilder = HttpURLConnectionBuilder()
+            .setUrl(url)
+            .setMethod(method)
+            .setHeaders(headers)
+            .setUrlParams(params, shouldEncode)
+            .setConnectTimeout(connectTimeout)
+            .setReadTimeout(readTimeout)
+            .setDisableRedirects(disableRedirects)
+            .openConnection()
+
+        val connection = connectionBuilder.build()
+
+        connection.setSSLSocketFactory(bridge)
+
+        val connectionInputStream = connection.inputStream
+        val fileOutputStream = FileOutputStream(file, false)
+
+        val contentLength = connection.getHeaderField("content-length")
+        var bytes = 0
+        var maxBytes = 0
+
+        try {
+            maxBytes = contentLength?.toInt() ?: 0
+        } catch (ignored: NumberFormatException) {
+        }
+
+        val buffer = ByteArray(1024)
+        var len: Int
+
+        // Throttle emitter to 100ms so it doesn't slow down app
+        var lastEmitTime = System.currentTimeMillis()
+        val minEmitIntervalMillis: Long = 100
+
+        while ((connectionInputStream.read(buffer).also { len = it }) > 0) {
+            fileOutputStream.write(buffer, 0, len)
+
+            bytes += len
+
+            if (progress!! && null != emitter) {
+                val currentTime = System.currentTimeMillis()
+                if (currentTime - lastEmitTime > minEmitIntervalMillis) {
+                    emitter.emit(bytes, maxBytes)
+                    lastEmitTime = currentTime
+                }
+            }
+        }
+
+        if (progress!! && null != emitter) {
+            emitter.emit(bytes, maxBytes)
+        }
+
+        connectionInputStream.close()
+        fileOutputStream.close()
+
+        val ret = JSObject()
+        ret.put("path", file!!.absolutePath)
+        return ret
+    }
+
+    interface FilesystemDownloadCallback {
+        fun onSuccess(result: JSObject)
+
+        fun onError(error: Exception)
+    }
+}
diff --git a/node_modules/@capacitor/filesystem/android/bin/src/main/kotlin/com/capacitorjs/plugins/filesystem/PluginResultExtensions.kt b/node_modules/@capacitor/filesystem/android/bin/src/main/kotlin/com/capacitorjs/plugins/filesystem/PluginResultExtensions.kt
new file mode 100644
index 0000000..7ca43b0
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/bin/src/main/kotlin/com/capacitorjs/plugins/filesystem/PluginResultExtensions.kt
@@ -0,0 +1,25 @@
+package com.capacitorjs.plugins.filesystem
+
+import com.getcapacitor.JSObject
+import com.getcapacitor.PluginCall
+
+/**
+ * Extension function to return a successful plugin result
+ * @param result JSOObject with the JSON content to return
+ * @param keepCallback boolean to determine if callback should be kept for future calls or not
+ */
+internal fun PluginCall.sendSuccess(result: JSObject? = null, keepCallback: Boolean = false) {
+    this.setKeepAlive(keepCallback)
+    if (result != null) {
+        this.resolve(result)
+    } else {
+        this.resolve()
+    }
+}
+
+/**
+ * Extension function to return a unsuccessful plugin result
+ * @param error error class representing the error to return, containing a code and message
+ */
+internal fun PluginCall.sendError(error: FilesystemErrors.ErrorInfo) =
+    this.reject(error.message, error.code)
\ No newline at end of file
diff --git a/node_modules/@capacitor/filesystem/android/build.gradle b/node_modules/@capacitor/filesystem/android/build.gradle
index 96f596a..19e1c9f 100644
--- a/node_modules/@capacitor/filesystem/android/build.gradle
+++ b/node_modules/@capacitor/filesystem/android/build.gradle
@@ -46,7 +46,7 @@ android {
 }
 
 kotlin {
-    jvmToolchain(21)
+    jvmToolchain(17)
 }
 
 repositories {
diff --git a/node_modules/@capacitor/filesystem/android/build/intermediates/aapt_friendly_merged_manifests/debug/aapt/AndroidManifest.xml b/node_modules/@capacitor/filesystem/android/build/intermediates/aapt_friendly_merged_manifests/debug/aapt/AndroidManifest.xml
new file mode 100644
index 0000000..0f95612
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/build/intermediates/aapt_friendly_merged_manifests/debug/aapt/AndroidManifest.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.capacitorjs.plugins.filesystem" >
+
+    <uses-sdk android:minSdkVersion="23" />
+
+</manifest>
\ No newline at end of file
diff --git a/node_modules/@capacitor/filesystem/android/build/intermediates/aapt_friendly_merged_manifests/debug/aapt/output-metadata.json b/node_modules/@capacitor/filesystem/android/build/intermediates/aapt_friendly_merged_manifests/debug/aapt/output-metadata.json
new file mode 100644
index 0000000..091ba10
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/build/intermediates/aapt_friendly_merged_manifests/debug/aapt/output-metadata.json
@@ -0,0 +1,18 @@
+{
+  "version": 3,
+  "artifactType": {
+    "type": "AAPT_FRIENDLY_MERGED_MANIFESTS",
+    "kind": "Directory"
+  },
+  "applicationId": "com.capacitorjs.plugins.filesystem",
+  "variantName": "debug",
+  "elements": [
+    {
+      "type": "SINGLE",
+      "filters": [],
+      "attributes": [],
+      "outputFile": "AndroidManifest.xml"
+    }
+  ],
+  "elementType": "File"
+}
\ No newline at end of file
diff --git a/node_modules/@capacitor/filesystem/android/build/intermediates/aar_metadata/debug/aar-metadata.properties b/node_modules/@capacitor/filesystem/android/build/intermediates/aar_metadata/debug/aar-metadata.properties
new file mode 100644
index 0000000..1211b1e
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/build/intermediates/aar_metadata/debug/aar-metadata.properties
@@ -0,0 +1,6 @@
+aarFormatVersion=1.0
+aarMetadataVersion=1.0
+minCompileSdk=1
+minCompileSdkExtension=0
+minAndroidGradlePluginVersion=1.0.0
+coreLibraryDesugaringEnabled=false
diff --git a/node_modules/@capacitor/filesystem/android/build/intermediates/compile_r_class_jar/debug/R.jar b/node_modules/@capacitor/filesystem/android/build/intermediates/compile_r_class_jar/debug/R.jar
new file mode 100644
index 0000000..b57886f
Binary files /dev/null and b/node_modules/@capacitor/filesystem/android/build/intermediates/compile_r_class_jar/debug/R.jar differ
diff --git a/node_modules/@capacitor/filesystem/android/build/intermediates/compile_symbol_list/debug/R.txt b/node_modules/@capacitor/filesystem/android/build/intermediates/compile_symbol_list/debug/R.txt
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/@capacitor/filesystem/android/build/intermediates/incremental/debug/packageDebugResources/compile-file-map.properties b/node_modules/@capacitor/filesystem/android/build/intermediates/incremental/debug/packageDebugResources/compile-file-map.properties
new file mode 100644
index 0000000..f3e222f
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/build/intermediates/incremental/debug/packageDebugResources/compile-file-map.properties
@@ -0,0 +1 @@
+#Thu Jul 24 20:43:42 IST 2025
diff --git a/node_modules/@capacitor/filesystem/android/build/intermediates/incremental/debug/packageDebugResources/merger.xml b/node_modules/@capacitor/filesystem/android/build/intermediates/incremental/debug/packageDebugResources/merger.xml
new file mode 100644
index 0000000..80815d5
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/build/intermediates/incremental/debug/packageDebugResources/merger.xml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="utf-8"?>
+<merger version="3"><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="main$Generated" generated="true" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="D:\PWA2APK-main\node_modules\@capacitor\filesystem\android\src\main\res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="main" generated-set="main$Generated" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="D:\PWA2APK-main\node_modules\@capacitor\filesystem\android\src\main\res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="debug$Generated" generated="true" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="D:\PWA2APK-main\node_modules\@capacitor\filesystem\android\src\debug\res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="debug" generated-set="debug$Generated" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="D:\PWA2APK-main\node_modules\@capacitor\filesystem\android\src\debug\res"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="generated$Generated" generated="true" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="D:\PWA2APK-main\node_modules\@capacitor\filesystem\android\build\generated\res\resValues\debug"/></dataSet><dataSet aapt-namespace="http://schemas.android.com/apk/res-auto" config="generated" generated-set="generated$Generated" ignore_pattern="!.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"><source path="D:\PWA2APK-main\node_modules\@capacitor\filesystem\android\build\generated\res\resValues\debug"/></dataSet><mergedItems/></merger>
\ No newline at end of file
diff --git a/node_modules/@capacitor/filesystem/android/build/intermediates/local_only_symbol_list/debug/R-def.txt b/node_modules/@capacitor/filesystem/android/build/intermediates/local_only_symbol_list/debug/R-def.txt
new file mode 100644
index 0000000..78ac5b8
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/build/intermediates/local_only_symbol_list/debug/R-def.txt
@@ -0,0 +1,2 @@
+R_DEF: Internal format may change without notice
+local
diff --git a/node_modules/@capacitor/filesystem/android/build/intermediates/manifest_merge_blame_file/debug/manifest-merger-blame-debug-report.txt b/node_modules/@capacitor/filesystem/android/build/intermediates/manifest_merge_blame_file/debug/manifest-merger-blame-debug-report.txt
new file mode 100644
index 0000000..e845338
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/build/intermediates/manifest_merge_blame_file/debug/manifest-merger-blame-debug-report.txt
@@ -0,0 +1,7 @@
+1<?xml version="1.0" encoding="utf-8"?>
+2<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+3    package="com.capacitorjs.plugins.filesystem" >
+4
+5    <uses-sdk android:minSdkVersion="23" />
+6
+7</manifest>
diff --git a/node_modules/@capacitor/filesystem/android/build/intermediates/merged_manifest/debug/AndroidManifest.xml b/node_modules/@capacitor/filesystem/android/build/intermediates/merged_manifest/debug/AndroidManifest.xml
new file mode 100644
index 0000000..0f95612
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/build/intermediates/merged_manifest/debug/AndroidManifest.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.capacitorjs.plugins.filesystem" >
+
+    <uses-sdk android:minSdkVersion="23" />
+
+</manifest>
\ No newline at end of file
diff --git a/node_modules/@capacitor/filesystem/android/build/intermediates/navigation_json/debug/navigation.json b/node_modules/@capacitor/filesystem/android/build/intermediates/navigation_json/debug/navigation.json
new file mode 100644
index 0000000..0637a08
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/build/intermediates/navigation_json/debug/navigation.json
@@ -0,0 +1 @@
+[]
\ No newline at end of file
diff --git a/node_modules/@capacitor/filesystem/android/build/intermediates/symbol_list_with_package_name/debug/package-aware-r.txt b/node_modules/@capacitor/filesystem/android/build/intermediates/symbol_list_with_package_name/debug/package-aware-r.txt
new file mode 100644
index 0000000..1da14a1
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/build/intermediates/symbol_list_with_package_name/debug/package-aware-r.txt
@@ -0,0 +1 @@
+com.capacitorjs.plugins.filesystem
diff --git a/node_modules/@capacitor/filesystem/android/build/outputs/logs/manifest-merger-debug-report.txt b/node_modules/@capacitor/filesystem/android/build/outputs/logs/manifest-merger-debug-report.txt
new file mode 100644
index 0000000..93cbac2
--- /dev/null
+++ b/node_modules/@capacitor/filesystem/android/build/outputs/logs/manifest-merger-debug-report.txt
@@ -0,0 +1,16 @@
+-- Merging decision tree log ---
+manifest
+ADDED from D:\PWA2APK-main\node_modules\@capacitor\filesystem\android\src\main\AndroidManifest.xml:1:1-2:12
+INJECTED from D:\PWA2APK-main\node_modules\@capacitor\filesystem\android\src\main\AndroidManifest.xml:1:1-2:12
+	package
+		INJECTED from D:\PWA2APK-main\node_modules\@capacitor\filesystem\android\src\main\AndroidManifest.xml
+	xmlns:android
+		ADDED from D:\PWA2APK-main\node_modules\@capacitor\filesystem\android\src\main\AndroidManifest.xml:1:11-69
+uses-sdk
+INJECTED from D:\PWA2APK-main\node_modules\@capacitor\filesystem\android\src\main\AndroidManifest.xml reason: use-sdk injection requested
+INJECTED from D:\PWA2APK-main\node_modules\@capacitor\filesystem\android\src\main\AndroidManifest.xml
+INJECTED from D:\PWA2APK-main\node_modules\@capacitor\filesystem\android\src\main\AndroidManifest.xml
+	android:targetSdkVersion
+		INJECTED from D:\PWA2APK-main\node_modules\@capacitor\filesystem\android\src\main\AndroidManifest.xml
+	android:minSdkVersion
+		INJECTED from D:\PWA2APK-main\node_modules\@capacitor\filesystem\android\src\main\AndroidManifest.xml
